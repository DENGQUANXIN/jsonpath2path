"""=====目标=====
输入 `JSON数据` 和 `JSON修改要求或目标`, 据此生成对应的 `JSONPathToPath命令序列`。

=====步骤=====
1. 通过原理、命令语法、预设转换器、示例，一步步理解 JSON树及其节点与槽模型，明确 JSONPathToPath 的功能和约束；
2. 针对输入`json_data`和`requirement`：
    2.1. 通过节点与槽模型分解其操作；
    2.2 通过 `JSONPath` 描述操作涉及的位置；
    2.3 通过特定的 `Converter` 来实现操作所需的特定转换；
    2.4 通过选择正确的赋值操作符，实现最终的节点移动到槽。
3. 将涉及的 `JSONPath` 和 `Converter`, 严格按照 命令语法 中定义的规则生成为一个或多个 JSONPathToPath 命令；
4. 得到操作序列后，严格按顺序一一模拟输出每一个操作，检查最终能否将输入`json_data`可以转换至满足`requirement`：
    4.1 首先判断前面的命令是否会对后面的命令造成影响，从而导致错误的结果：
        4.1.1 注意：JSONPathToPath 序列中的命令是依次顺序执行，每个命令都可能会修改输入`json_data`，对后续命令造成影响；
        4.1.2 若存在问题，可以通过增加临时槽($.__temp_slot)的方式来解决，并回到第 3 步重新生成。
    4.2 然后检查命令是否会造成不必要的修改，从而导致多余的副作用：
        4.2.1 若存在问题，更换其它能够起到相同预期但不存在副作用的一条或多条命令，并回到第 3 步重新生成。
5. 注意：仅需输出最终的命令序列。

=====原理=====
在深入讨论之前，我们需要先理解JSON的树状结构。JSON 数据可以被看作是一棵树，其中每个节点代表一个dict、list、str、number、bool或null。树的边由字典的键（key）或列表的索引（index）组成，而节点则是具体的值。
槽（slot）是JSON处理方法的一个核心概念。槽可以理解为JSON树中用于放置边（key或index）和节点（value）的位置。每个槽可以容纳一个节点或一条边，而JSON的操作本质上就是对槽的占用与释放。
在JSON树模型下，所有的JSON操作都可以被看作是将节点（或边）移动到槽的过程。无论是添加、修改还是删除数据，本质上都是在调整节点或边在槽中的位置。
当一个槽已经被占用时，新的节点或边会覆盖原有的内容。这种覆盖行为是JSON批处理中的常见操作，例如：如果将一个值放入一个已被占用的槽中，原有的值会被替换。如果将一个对象或数组放入一个已被占用的槽中，原有的数据结构会被完全替换。
list类型越界替换/挂载，默认采取追加模式，即若idx >= len(list)则追加到list之后。
JSON批处理的核心是将复杂的操作分解为节点和槽之间的一一对应关系。通过将每个操作映射为“将某个节点放入某个槽”的简单任务，我们可以将批处理问题转化为以下步骤：
1. 获取节点列表：由 JSON Path 匹配获取，或者直接生成一批新节点；
2. 获取槽列表：由 JSON Path 匹配获取槽位置；
3. 隐含的一一对应：节点列表和槽列表必须是一一对应的或通过一些转换可以做到一一对应的；
4. 执行操作：将节点一一移动到槽。
本文设计方法仅支持四种节点和槽点对应关系：
1 : 1 无需转换
N : N 按照列表索引一一对应
1 : N 将节点复制为 N 份一一对应
N : 1 仅支持挂载操作，目标位置类型对应操作：
- list：在列表后追加 N 个节点
- dict：挂载对应的 N 个键值对位置，要求N个键各不相同

=====命令语法=====
# 语法规则
( @jsonpath / jsonpath / `list` ) [ | convert_func [ param ]... ]... ( -> / => ) jsonpath

# 详细说明
( @jsonpath / jsonpath / list )
1. 使用圆括号 () 明确分组, 定义了数据源，表示必须选择以下三种形式之一：
2. @jsonpath：以 @ 开头的 JSONPath 字符串。
3. jsonpath：普通的 JSONPath 字符串。
4. `list`：用反引号包裹的 JSON 二维列表:
    4.1. 格式为: [[k1,v1],[k2,v2],...]。
    4.2. k是json中dict的键或list的索引，v是json中dict的值或list的元素。
5. 使用 / 表示“或”，避免与管道符号 | 混淆。

[ | convert_func [ param ]... ]...
1. |：表示管道符，用于连接多个操作。
2. convert_func：表示一个转换方法名。
3. [ param ]...：表示方法的参数，可以省略，也可以有多个:
    3.1. param可以是数值、双引号包裹的字符串、布尔值(true/false)、反引号包裹的JSON字符串。
4. 整体可以重复多次，表示可以串联多个转换方法。

( -> / => )
1. 使用圆括号 () 明确分组，表示必须选择以下两种赋值类型之一：
2. ->：表示将节点值覆盖到 目标JSONPath 对应的JSON节点的值上, 该操作称为 占用(occupy)。
3. =>：表示将边和节点挂载到 目标JSONPath 对应的JSON节点上, 该操作称为 挂载(mount)。
4. 使用 / 表示“或”，避免与管道符号 | 混淆。

jsonpath
1. 表示 目标JSONPath 字符串，用于指定赋值的目标。

=====预设converter=====
v_add: 加操作
- param1: 必填操作, 加上的内容
- param2: jsonpath, 节点中需要进行加操作的子节点

sort: 排序
- param1: bool类型, 是否倒排
- param2: jsonpath, 排序依据的节点中的子节点

reverse: 倒序

=====示例=====
######################
---Examples---
######################
json_data: {"store":{"book":[{"title":"Book1","price":10},{"title":"Book2","price":20}],"bicycle":{"color":"red","price":100}}}

示例1:
requirement:
为书增加作者信息为Anonymous
################
Output:
`[["author", "Anonymous"]]` => $.store.book[*]

示例2:
requirement:
为书增加作者信息为"标题_author"
################
Output:
@$.store.book[*].title | v_add "_author" -> $.store.book[*].author

示例3:
requirement:
移除第二本书
################
Output:
$.store.book[1]->

示例4:
requirement:
移除价格大于20的书
################
Output:
$.store.book[?(@.price>20)]->

示例5:
requirement:
将书按照价格的倒序排列
################
Output:
@$.store.book[*] | sort true $.price => $.store.book

示例5:
requirement:
去掉商店层级
################
Output:
$.store.* => $
$.store ->

#############################
---Real Data---
######################
json_data: {"store":{"book":[{"title":"Book1","price":10},{"title":"Book2","price":20}],"bicycle":{"color":"red","price":100}}}
requirement:
新增一本价格为30的Book3，先交换Book1和Book2的位置，对除第一本外的其它书按照价格逆序排序，修改当前自行车的颜色为蓝色，保留原有自行车并新增一辆价格80的黄色自行车
######################
Output:"""


